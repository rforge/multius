sample(1:24, probabilities)
sample(1:24, prob = probabilities, size = 1)
1-probabilities
probabilities
rownames(initial)
nrow(initial)
1:nrow(initial)
1:nrow(initial)[-actor]
actor
c(1:nrow(initial))[-actor]
probabilities
which.max(probabilities)
which.max(probabilities[-actor])
probabilities
order(probabilities)
assign(1:24, probabilities)
assign(probabilities, 1:24)
assign(as.character(1:24), probabilities)
probabilities
order(probabilities)
which.max(order(probabilities))
order(probabilities)
cbind(1:24, order(probabilities))
cbind(1:24, order(probabilities))[-actor,]
cbind(1:24, order(probabilities))[-actor,]
urej <- cbind(1:24, order(probabilities))[-actor,]
which.max(urej[,2])
urej[which.max(urej[,2]),1]
urej <- cbind(1:24, order(probabilities))[-actor,]
alter <- urej[which.max(urej[,2]),1]
urej <- cbind(1:24, order(probabilities))[-actor,]
urej
pop   <- myPhD::popularity(network = initial, actor = actor)[actor]
D     <- q + a*pop
urej  <- cbind(1:24, order(probabilities))[-actor,]
a <- -0.4
pop   <- myPhD::popularity(network = initial, actor = actor)[actor]
D     <- q + a*pop
urej  <- cbind(1:24, order(probabilities))[-actor,]
quantile(probabilities, probs = 1-b)
probabilities
sample(which(probabilities >= quantile(probabilities, probs = 1-b)), 1)
urej
urej  <- cbind(1:24, order(probabilities), probabilities)[-actor,]
urej
urej
sample(which(urej[,3] >= quantile(urej♥[,3], probs = 1-b)), 1)
sample(which(urej[,3] >= quantile(urej[,3], probs = 1-b)), 1)
urej[,3]
quantile(urej[,3], probs = 1-b)
which(urej[,3] >= quantile(urej[,3], probs = 1-b)
sample(), 1)
which(urej[,3] >= quantile(urej[,3], probs = 1-b))
urej[which(urej[,3] >= quantile(urej[,3], probs = 1-b)), 1]
alters <- urej[which(urej[,3] >= quantile(urej[,3], probs = 1-b)), 1]
sample(urej[which(urej[,3] >= quantile(urej[,3], probs = 1-b)), 1], 1)
quantile(urej[,3], probs = b)
quantile(urej[,3], probs = 1-b)
quantile(urej[,3], probs = 1-b)
quantile(urej[,3], probs = b)
urej[which(urej[,3] >= quantile(urej[,3], probs = 1-b))
)
which(urej[,3] >= quantile(urej[,3], probs = 1-b)
)
which(urej[,3] >= quantile(urej[,3], probs = 1-b))
which(urej[,3] <= quantile(urej[,3], probs = b)), 1], 1)
which(urej[,3] <= quantile(urej[,3], probs = b))
network
network[actor,]
mutuality
data
install.packages("roxygen2")
#--- empiricni CF
sym.network <- network + t(network)
#--- empiricni CF
sym.network <- network + t(network); sym.network[sym.network > 1] <- 1
ifelse(test = symmetrize == TRUE, yes = sym.network, no = network)
symmetrize = FALSE
ifelse(test = symmetrize == TRUE, yes = sym.network, no = network)
ifelse(test = symmetrize == TRUE, yes = 2, no = 1)
ifelse(test = symmetrize == FALSE, yes = 2, no = 1)
symmetrize <- FALSE
ifelse(test = symmetrize == FALSE, yes = "sym", no = "staro")
ifelse(test = symmetrize == TRUE, yes = "sym", no = "staro")
symmetrize <- TRUE
ifelse(test = symmetrize == TRUE, yes = "sym", no = "staro")
#--- rndCF
rndCF <- array(data = NA, dim = c(length(groups), length(bmType), nSim))
install.packages("http://www.cmi-fdv.si/projekti/arrs/wp-content/uploads/2014/07/myPhD_0.9.4.zip", repos=NULL)
#--- empiricni CF
sym.network <- network + t(network); sym.network[sym.network > 1] <- 1
sym.network
plot.mat(sym.network)
library(blockmodeling)
plot.mat(sym.network)
#--- empiricni CF
sym.network <- network + t(network); sym.network[sym.network > 1] <- 1
empCF <- matrix(NA, nrow = length(groups), ncol = length(bmType))
err(optRandomParC(M = ifelse(test = symmetrize == TRUE, yes = sym.network, no = network),
k = i,
rep = 100,
approach = "bin",
blocks = blocks,
nCores = nCores))
blocks <- ccps
blocks <- ccps(3)
err(optRandomParC(M = ifelse(test = symmetrize == TRUE, yes = sym.network, no = network),
k = i,
rep = 100,
approach = "bin",
blocks = blocks,
nCores = nCores))
nCores = 0
err(optRandomParC(M = ifelse(test = symmetrize == TRUE, yes = sym.network, no = network),
k = i,
rep = 100,
approach = "bin",
blocks = blocks,
nCores = nCores))
i
i <- 3
err(optRandomParC(M = ifelse(test = symmetrize == TRUE, yes = sym.network, no = network),
k = i,
rep = 100,
approach = "bin",
blocks = blocks,
nCores = nCores))
i
ifelse(test = symmetrize == TRUE, yes = sym.network, no = network)
symmetrize == TRUE
ifelse(test = symmetrize == TRUE, yes = sym.network, no = network)
sym.network
network
ifelse(test = symmetrize == TRUE, yes = list(sym.network), no = list(network))
ifelse(test = symmetrize == TRUE, yes = list(sym.network), no = list(network))[[♥1]]
ifelse(test = symmetrize == TRUE, yes = list(sym.network), no = list(network))[[1]]
randomize(network)
randomize
install.packages("roxygen2")
install.packages("ergm")
d <- unlist(lapply(shortest_paths(graph = graph_from_adjacency_matrix(as.matrix(network)), from = actor)$vpath, length))
library(igraph)
d <- unlist(lapply(shortest_paths(graph = graph_from_adjacency_matrix(as.matrix(network)), from = actor)$vpath, length))
network<-
matrix(0, nrow = 10, ncol = 10)
d <- unlist(lapply(shortest_paths(graph = graph_from_adjacency_matrix(as.matrix(network)), from = actor)$vpath, length))
actor <- 5
d <- unlist(lapply(shortest_paths(graph = graph_from_adjacency_matrix(as.matrix(network)), from = actor)$vpath, length))
suppressWarnings(d <- unlist(lapply(shortest_paths(graph = graph_from_adjacency_matrix(as.matrix(network)), from = actor)$vpath, length))))
suppressWarnings(d <- unlist(lapply(shortest_paths(graph = graph_from_adjacency_matrix(as.matrix(network)), from = actor)$vpath, length)))
popularity <- colSums(network)/nrow(network)
relative.popularity <- popularity/sum(popularity)
relative.popularity[is.nan(relative.popularity)] <- 0
assortativity
same.popularity
b <- matrix(NA, nrow = nbl, ncol = nbl)
b[upper.tri(b)] <- "nul"
diag(b) <- "com"
b[nbl, nbl] <- "dnc"
b[lower.tri(b)] <- "dnc"
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI >= quantile(PEI, probs = 0.75))
PEI <- 1:10
E <- 5
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI >= quantile(PEI, probs = 0.75))
D
PEI
E
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI >= quantile(PEI, probs = 0.75))
D
E <- 9
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI >= quantile(PEI, probs = 0.75))
D
PEI[-E]
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
E
PEI
E
PEI[-E]
PEI[-E]
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
which(E < D)
which(E > D)
D[which(E > D)] <- D[which(E > D)] + 1
E <- 5
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
D[which(E > D)] <- D[which(E > D)] + 1
D
PEI
E
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
E
D
which(E > D)
D[which(E < D)] <- D[which(E < D)] + 1
D
E <- 9
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
D[which(E < D)] <- D[which(E < D)] + 1
D
D[which(E < D)]
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
E
D
E
E < 1:n
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D[which(E < nrow(initial.network))] <- D[which(E < nrow(initial.network))] + 1
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
rnorm(10)
abs(rnorm(10))
PEI <- abs(rnorm(10))
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
E
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI[-E] >= quantile(PEI[-E], probs = 0.75))
D
quantile(PEI[-E], probs = 0.75)
quantile(PEI[-E], probs = 0.75)
PEI >= quantile(PEI[-E], probs = 0.75)
which(PEI >= quantile(PEI[-E], probs = 0.75))
D <- which(PEI >= quantile(PEI[-E], probs = 0.75))
D %in% E
-D %in% E
-(D %in% E)
!(D %in% E)
D[!(D %in% E)]
D <- D[!(D %in% E)]
PEI <- 1:10
D
E <- 9
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI >= quantile(PEI[-E], probs = 0.75))
D
D <- D[!(D %in% E)]
D
#################### NAJMANJ IN NAJBOLJ UGODNI
D <- which(PEI >= quantile(PEI[-E], probs = 0.75))
D
initialNetwork
lambda
lambda <- 5
newbie
newbie <- c(2, 20)
newbie
kappa
newbie <- c(20, 20)
kappa <- 2
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
initial.network
network
initial.network <- network
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps
i <- 10
which(steps >= i)
steps[which(steps >= i)[1]]
1/steps[which(steps >= i)[1]]
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps
i <- 10
1/steps[which(steps >= i)[1]]
i <- 120
1/steps[which(steps >= i)[1]]
steps
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps
steps
employing
employing <- steps[-length(steps)]
employing
steps[which(steps >= i)[1]]
i <- 1
steps[which(steps >= i)[1]]
steps[which(steps >= 100)[1]]
steps[which(steps >= 101)[1]]
razdalje <- geodist(network, inf.replace = 0)$gdist
library(igraph)
razdalje <- geodist(network, inf.replace = 0)$gdist
library(sna)
razdalje <- geodist(network, inf.replace = 0)$gdist
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
Hi <- colSums(omejene_razdalje)
Hi
network
network <- matrix(sample(c(0, 1), size = 10*10, replace = T), nrow = 10)
razdalje <- geodist(network, inf.replace = 0)$gdist
razdalje
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
omejene_razdalje
Hi <- colSums(omejene_razdalje)
Hi
razdalje <- geodist(network, inf.replace = 0)$gdist
razdalje
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
omejene_razdalje
Hi <- colSums(omejene_razdalje)
Hi
Hi <- (Hi - Hi[actor])**2
Hi
actor
Hi[actor]
Hi
razdalje <- geodist(network, inf.replace = 0)$gdist
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
Hi <- colSums(omejene_razdalje)
Hi
Hi[actor]
Hi <- (Hi - Hi[actor])**2
Hi
Hi <- prop.table(Hi)
Hi
Hi[is.nan(Hi)] <- 0
Hi
network <- cbind(c(1, 0, 0),
c(1, 1, 0),
c(0, 1, 0))
razdalje <- geodist(network, inf.replace = 0)$gdist
razdalje
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
omejene_razdalje
Hi <- colSums(omejene_razdalje)
Hi <- (Hi - Hi[actor])**2
Hi
razdalje <- geodist(network, inf.replace = 0)$gdist
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
Hi <- colSums(omejene_razdalje)
Hi
Hi <- (Hi - Hi[actor])**2
Hi
actor <- 2
Hi <- (Hi - Hi[actor])**2
Hi
razdalje <- geodist(network, inf.replace = 0)$gdist
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
Hi <- colSums(omejene_razdalje)
Hi
razdalje <- geodist(network, inf.replace = 0)$gdist
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
omejene_razdalje
Hi <- colSums(omejene_razdalje)
Hi
network
network <- rbind(c(1, 0, 0),
c(1, 1, 0),
c(0, 1, 0))
razdalje <- geodist(network, inf.replace = 0)$gdist
razdalje
omejene_razdalje <- (razdalje > 0) & (razdalje < 3)
Hi <- colSums(omejene_razdalje)
Hi
seq_len(10)
seq_len(15)
1:15
library(blockmodeling)
?`blockmodeling-package`
install.packages("roxygen2")
install.packages("devtools")
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
initial.network
initial.network <- matrix(sample(c(0, 1), size = 100, replace = TRUE), nrow = 10)
lambda <- 5
kappa <- 3
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
newbie <- c(10 ,10)
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps
employing <- steps[-length(steps)]
employing
steps <- lambda * (cumsum(c(nrow(initial.network), newbie)))*kappa
steps
steps <- (cumsum(c(nrow(initial.network), newbie)))*kappa*lambda
steps
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps
(cumsum(c(nrow(initial.network), newbie)))*kappa*lambda
forBeta <- (cumsum(c(nrow(initial.network), newbie)))*kappa*lambda
steps <- cumsum(forBeta)
steps
cumsum(forBeta)
cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps <- cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
steps
forBeta <- (cumsum(c(nrow(initial.network), newbie)))*kappa*lambda
forBeta
steps <- cumsum(forBeta)
steps
cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
newbie <- c(10, 5, 30, 10, 15)
cumsum(lambda * (cumsum(c(nrow(initial.network), newbie))))*kappa
forBeta <- (cumsum(c(nrow(initial.network), newbie)))*kappa*lambda
cumsum(forBeta)
which(steps >= i)[1]
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
devtools::document()
library(myPhD)
print.p(10)
myPhD::print.p(10)
myPhD:::print.p(10)
library(myPhD)
library(myPhD)
library(myPhD)
install.packages("roxygen")
devtools::document()
compileAttributes()
install.packages("roxygen2")
devtools::document()
help(add)
library(myPhD)
library(myPhD)
iss03
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
install.packages("roxygen2")
library(myPhD)
install.packages("comat")
install.packages("igraph")
install.packages("combinat")
library(myPhD)
install.packages("roxygen2")
library(myPhD)
library(myPhD)
saveActions == TRUE
saveActions <- TRUE
ifelse(saveActions == TRUE, matrix(NA, nrow = k, ncol = 3), NA)
k <- 5
ifelse(saveActions == TRUE, matrix(NA, nrow = k, ncol = 3), NA)
ifelse(saveActions == TRUE, yes = matrix(NA, nrow = k, ncol = 3), no = NA)
saveActions
k
matrix(NA, nrow = k, ncol = 3)
ifelse(saveActions == TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)
ifelse(saveActions == TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)[[1]]
ifelse(saveActions != TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)[[1]]
ifelse(saveActions == TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)[[1]]
# QUICK HELP
# initial = initial network
# formula = vector of coefitients
# k = number of iterations
# theta = vector of coeficientss
# q = verjetnost, s katero vzpostavimo povezavo ali (1-b) prekinemo povezavo
# b = izmed koliko zgornjih izbiramo?
# ce je sym=TRUE, potem so vse povezave in nepovezave nemudoma simetrizirane
networks <- list("final" = initial,
"initial" = initial,
"actions" = ifelse(saveActions == TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)[[1]])
initial <- rbind(c(1, 2, 30), c(1, 2, 3))
# QUICK HELP
# initial = initial network
# formula = vector of coefitients
# k = number of iterations
# theta = vector of coeficientss
# q = verjetnost, s katero vzpostavimo povezavo ali (1-b) prekinemo povezavo
# b = izmed koliko zgornjih izbiramo?
# ce je sym=TRUE, potem so vse povezave in nepovezave nemudoma simetrizirane
networks <- list("final" = initial,
"initial" = initial,
"actions" = ifelse(saveActions == TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)[[1]])
networks
saveActions <- FALSE
# QUICK HELP
# initial = initial network
# formula = vector of coefitients
# k = number of iterations
# theta = vector of coeficientss
# q = verjetnost, s katero vzpostavimo povezavo ali (1-b) prekinemo povezavo
# b = izmed koliko zgornjih izbiramo?
# ce je sym=TRUE, potem so vse povezave in nepovezave nemudoma simetrizirane
networks <- list("final" = initial,
"initial" = initial,
"actions" = ifelse(saveActions == TRUE, yes = list(matrix(NA, nrow = k, ncol = 3)), no = NA)[[1]])
networks
library(myPhD)
library(myPhD)
library(myPhD)
library(myPhD)
ddotchart()
library(nem)
